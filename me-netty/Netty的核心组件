Channel: JavaNIO的基本构造,可以看作一个数据入站出站的载体,因此他可以被打开或者被关闭
回调: 其实就是一个方法,一个指向已经被提供给另外一个方法的方法的引用,是操作完成后通知相关方的常见方法之一
Future: Future提供了另外一种操作完成时通知应用程序的方式,这个对象可以看作异步操作的占位符
事件和ChannelHandler: Netty使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发生的事件来触发适当的动作

Future,回调,ChannelHandler: Netty的异步编程模型是建立在Future和回调的基础上而将事件派发到ChannelHandler的方法则发生在更深的层次上。
结合在一起，这些元素就提供了一个处理环境，使你的应用程序逻辑可以独立于任何网络操作相关的顾虑而独立地演变。这也是Netty的设计方式的一个关键
目标。拦截操作以及高速地转换入站数据和出站数据，都只需要你提供回调或者利用操作所返回的Future。这使得链接操作变得既简单又高效，并且促进了
可重用的通用代码的编写

选择器、事件和EventLoop: Netty通过触发事件将Selector从应用程序中抽象出来，消除了所有本来将需要手动编写的派发代码。在内部，将会为每个
Channel分配一个EventLoop，用以处理所有事件，包括：注册感兴趣的事件；将事件派发给ChannelHandler；安排进一步的动作。EventLoop本身只由
一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。这个简单而强大的设计消除了你可能有的在
ChannelHandler实现中需要进行同步的任何顾虑，因此，你可以专注于提供正确的逻辑，用来在有感兴趣的数据要处理的时候执行